# JavaScript Topics and Subtopics

---

## Table of Contents

- [JavaScript Topics and Subtopics](#javascript-topics-and-subtopics)
  - [Table of Contents](#table-of-contents)
- [0\_hello.js — Basic Console Output](#0_hellojs--basic-console-output)
  - [Overview](#overview)
  - [Syntax \& Examples](#syntax--examples)
  - [Key Takeaways](#key-takeaways)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings)
  - [Practice](#practice)
  - [Further Reading](#further-reading)
- [1\_variable.js — JavaScript Variables](#1_variablejs--javascript-variables)
  - [Overview](#overview-1)
  - [Syntax \& Examples](#syntax--examples-1)
  - [Key Takeaways](#key-takeaways-1)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-1)
  - [Practice](#practice-1)
  - [Further Reading](#further-reading-1)
  - [Difference Between var, let, and const](#difference-between-var-let-and-const)
    - [Overview](#overview-2)
    - [Syntax \& Examples](#syntax--examples-2)
    - [Key Takeaways](#key-takeaways-2)
    - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-2)
    - [Practice](#practice-2)
    - [Further Reading](#further-reading-2)
- [2\_dataType.js — JavaScript Data Types](#2_datatypejs--javascript-data-types)
  - [Overview](#overview-3)
  - [Syntax \& Examples](#syntax--examples-3)
  - [Key Takeaways](#key-takeaways-3)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-3)
  - [Practice](#practice-3)
  - [Further Reading](#further-reading-3)
- [3\_conversionOperation.js — JavaScript Type Conversion](#3_conversionoperationjs--javascript-type-conversion)
  - [Overview](#overview-4)
  - [Syntax \& Examples](#syntax--examples-4)
  - [Key Takeaways](#key-takeaways-4)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-4)
  - [Practice](#practice-4)
  - [Further Reading](#further-reading-4)
- [4\_operation.js — JavaScript Operations](#4_operationjs--javascript-operations)
  - [Overview](#overview-5)
  - [Syntax \& Examples](#syntax--examples-5)
  - [Key Takeaways](#key-takeaways-5)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-5)
  - [Practice](#practice-5)
  - [Further Reading](#further-reading-5)
- [5\_comparison.js — JavaScript Comparisons](#5_comparisonjs--javascript-comparisons)
  - [Overview](#overview-6)
  - [Syntax \& Examples](#syntax--examples-6)
  - [Key Takeaways](#key-takeaways-6)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-6)
  - [Practice](#practice-6)
  - [Further Reading](#further-reading-6)
- [6\_strings.js — JavaScript Strings](#6_stringsjs--javascript-strings)
  - [Overview](#overview-7)
  - [Syntax \& Examples](#syntax--examples-7)
  - [Key Takeaways](#key-takeaways-7)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-7)
  - [Practice](#practice-7)
  - [Further Reading](#further-reading-7)
- [7\_numberMath.js — JavaScript Numbers and Math](#7_numbermathjs--javascript-numbers-and-math)
  - [Overview](#overview-8)
  - [Syntax \& Examples](#syntax--examples-8)
  - [Key Takeaways](#key-takeaways-8)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-8)
  - [Practice](#practice-8)
  - [Further Reading](#further-reading-8)
- [8\_dates.js — JavaScript Dates](#8_datesjs--javascript-dates)
  - [Overview](#overview-9)
  - [Syntax \& Examples](#syntax--examples-9)
  - [Key Takeaways](#key-takeaways-9)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-9)
  - [Practice](#practice-9)
  - [Further Reading](#further-reading-9)
- [9\_array.js — JavaScript Arrays](#9_arrayjs--javascript-arrays)
  - [Overview](#overview-10)
  - [Syntax \& Examples](#syntax--examples-10)
    - [Array Creation](#array-creation)
      - [1. Array Literal](#1-array-literal)
      - [2. Array Constructor](#2-array-constructor)
      - [3. Array.of](#3-arrayof)
      - [4. Array.from](#4-arrayfrom)
    - [Accessing and Modifying Elements](#accessing-and-modifying-elements)
    - [Mutating vs Non-Mutating Methods](#mutating-vs-non-mutating-methods)
      - [Mutating Methods](#mutating-methods)
      - [Non-Mutating Methods](#non-mutating-methods)
    - [Searching and Checking](#searching-and-checking)
    - [Extraction and Combination](#extraction-and-combination)
    - [Flattening Arrays](#flattening-arrays)
    - [Utility Methods](#utility-methods)
    - [Iteration](#iteration)
      - [for Loop](#for-loop)
      - [for...of Loop](#forof-loop)
      - [forEach](#foreach)
      - [map](#map)
      - [filter](#filter)
      - [reduce](#reduce)
    - [Array-like Objects and Conversion](#array-like-objects-and-conversion)
    - [Destructuring Arrays](#destructuring-arrays)
    - [Multidimensional and Nested Arrays](#multidimensional-and-nested-arrays)
  - [Comparison Table: Array Methods](#comparison-table-array-methods)
  - [Real-World Use Cases](#real-world-use-cases)
  - [Key Takeaways](#key-takeaways-10)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-10)
  - [Practice](#practice-10)
  - [Further Reading](#further-reading-10)
- [10\_objects.js — JavaScript Objects](#10_objectsjs--javascript-objects)
  - [Overview](#overview-11)
  - [Syntax \& Examples](#syntax--examples-11)
    - [Object Creation](#object-creation)
      - [1. Object Literal](#1-object-literal)
      - [2. Object Constructor](#2-object-constructor)
      - [3. Object.create](#3-objectcreate)
    - [Property Access](#property-access)
      - [Dot Notation](#dot-notation)
      - [Bracket Notation (for dynamic or special keys)](#bracket-notation-for-dynamic-or-special-keys)
      - [Computed Property Names](#computed-property-names)
      - [Symbol Properties](#symbol-properties)
    - [Property Descriptors \& Immutability](#property-descriptors--immutability)
      - [Object.freeze](#objectfreeze)
      - [Object.seal](#objectseal)
      - [Defining Property Descriptors](#defining-property-descriptors)
    - [Methods \& `this`](#methods--this)
      - [Regular Method](#regular-method)
      - [Arrow Function Pitfall](#arrow-function-pitfall)
    - [Nested Objects \& Arrays of Objects](#nested-objects--arrays-of-objects)
    - [Object Utility Methods](#object-utility-methods)
    - [Merging \& Cloning Objects](#merging--cloning-objects)
      - [Shallow Copy](#shallow-copy)
      - [Deep Copy (using JSON, for simple objects)](#deep-copy-using-json-for-simple-objects)
    - [Destructuring \& Default Values](#destructuring--default-values)
    - [Iteration](#iteration-1)
      - [for...in (keys)](#forin-keys)
      - [Object.entries (keys \& values)](#objectentries-keys--values)
  - [Comparison Table: Object Features \& Methods](#comparison-table-object-features--methods)
  - [Real-World Use Cases](#real-world-use-cases-1)
  - [Key Takeaways](#key-takeaways-11)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-11)
  - [Practice](#practice-11)
  - [Further Reading](#further-reading-11)
- [11\_function\_and\_parameter.js — JavaScript Functions and Parameters](#11_function_and_parameterjs--javascript-functions-and-parameters)
  - [Overview](#overview-12)
  - [Syntax \& Examples](#syntax--examples-12)
    - [1. Function Declaration (Named Function)](#1-function-declaration-named-function)
    - [2. Function Expression](#2-function-expression)
    - [3. Arrow Function Expression](#3-arrow-function-expression)
    - [4. Anonymous Function](#4-anonymous-function)
    - [5. Parameters and Arguments](#5-parameters-and-arguments)
    - [6. Return Values and Side Effects](#6-return-values-and-side-effects)
    - [7. Scope and Closures](#7-scope-and-closures)
    - [8. Hoisting](#8-hoisting)
  - [Comparison Table: Function Types](#comparison-table-function-types)
  - [Real-World Use Cases](#real-world-use-cases-2)
  - [Key Takeaways](#key-takeaways-12)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-12)
  - [Practice](#practice-12)
  - [Further Reading](#further-reading-12)
- [12\_arrow\_function.js — JavaScript Arrow Functions](#12_arrow_functionjs--javascript-arrow-functions)
  - [Overview](#overview-13)
  - [Syntax \& Examples](#syntax--examples-13)
    - [Basic Syntax](#basic-syntax)
    - [Arrow Functions and `this`](#arrow-functions-and-this)
    - [Arrow Functions and `arguments`](#arrow-functions-and-arguments)
    - [Arrow Functions and Constructors](#arrow-functions-and-constructors)
    - [Arrow Functions and call/apply/bind](#arrow-functions-and-callapplybind)
    - [Arrow Functions in Array Methods](#arrow-functions-in-array-methods)
    - [Arrow Functions in Promises and Callbacks](#arrow-functions-in-promises-and-callbacks)
  - [When **Not** to Use Arrow Functions](#when-not-to-use-arrow-functions)
  - [Best Practices \& Common Pitfalls](#best-practices--common-pitfalls)
  - [Comparison Table: Arrow Functions vs Regular Functions](#comparison-table-arrow-functions-vs-regular-functions)
  - [Real-World Use Cases](#real-world-use-cases-3)
  - [Key Takeaways](#key-takeaways-13)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-13)
  - [Practice](#practice-13)
  - [Further Reading](#further-reading-13)
- [13\_Immediately\_Invoked\_Function\_Expressions\_(IIFE).js — Immediately Invoked Function Expressions (IIFE)](#13_immediately_invoked_function_expressions_iifejs--immediately-invoked-function-expressions-iife)
  - [Overview](#overview-14)
  - [Syntax \& Examples](#syntax--examples-14)
    - [Classic IIFE Syntax](#classic-iife-syntax)
    - [Why Parentheses?](#why-parentheses)
    - [IIFE with Return Value](#iife-with-return-value)
    - [IIFE for Scope Isolation](#iife-for-scope-isolation)
  - [Use Cases for IIFE](#use-cases-for-iife)
  - [Best Practices \& Common Pitfalls](#best-practices--common-pitfalls-1)
  - [Comparison: IIFE vs Regular Function](#comparison-iife-vs-regular-function)
  - [Real-World Use Cases](#real-world-use-cases-4)
  - [Key Takeaways](#key-takeaways-14)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-14)
  - [Practice](#practice-14)
  - [Further Reading](#further-reading-14)
- [14\_control\_flow.js — JavaScript Control Flow](#14_control_flowjs--javascript-control-flow)
  - [Overview](#overview-15)
  - [Syntax \& Examples](#syntax--examples-15)
    - [1. if/else Statement](#1-ifelse-statement)
    - [2. switch Statement](#2-switch-statement)
    - [3. Ternary Operator](#3-ternary-operator)
    - [4. Logical Operators (\&\&, ||, !)](#4-logical-operators---)
    - [5. Nullish Coalescing Operator (??)](#5-nullish-coalescing-operator-)
    - [6. Truthy and Falsy Values](#6-truthy-and-falsy-values)
    - [7. Checking for Empty Arrays and Objects](#7-checking-for-empty-arrays-and-objects)
  - [Comparison Table: JavaScript Control Flow Constructs](#comparison-table-javascript-control-flow-constructs)
  - [Key Takeaways](#key-takeaways-15)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-15)
  - [Practice](#practice-15)
  - [Further Reading](#further-reading-15)
- [15\_loops.js — JavaScript Loops](#15_loopsjs--javascript-loops)
  - [Overview](#overview-16)
  - [Syntax \& Examples](#syntax--examples-16)
    - [1. For Loop](#1-for-loop)
    - [2. While Loop](#2-while-loop)
    - [3. Do-While Loop](#3-do-while-loop)
    - [4. For...of Loop](#4-forof-loop)
    - [5. For...in Loop](#5-forin-loop)
    - [6. forEach Method](#6-foreach-method)
    - [7. map Method](#7-map-method)
    - [8. filter Method](#8-filter-method)
    - [9. reduce Method](#9-reduce-method)
  - [Comparison Table: JavaScript Loop Types](#comparison-table-javascript-loop-types)
  - [Key Takeaways](#key-takeaways-16)
  - [Common Pitfalls \& Warnings](#common-pitfalls--warnings-16)
  - [Practice](#practice-16)
  - [Further Reading](#further-reading-16)

---

# 0_hello.js — Basic Console Output

**Learning Goals:**
- Understand how to use `console.log()` for debugging and output.
- Learn to visually separate console output for clarity.

---

## Overview

`console.log()` is the primary way to print output in JavaScript, useful for debugging and inspecting values.

---

## Syntax & Examples

```js
console.log("hello");
console.log('%c==================================================================', 'color: green; font-weight: bold;');
```

---

## Key Takeaways
> - Use `console.log()` for outputting all types of values.
> - Use styled separator lines to visually distinguish output sections.

---

## Common Pitfalls & Warnings
> ⚠️ **Warning:**
> Too many or unlabeled `console.log()` statements can clutter your output and make debugging harder.

---

## Practice
**Try it yourself:**
- Print your name and age using `console.log()`.
- Add a separator line after your output.

**Quiz:**
```js
console.log('Hello' + 5);
// What does this print?
```

---

## Further Reading
- [MDN: console.log()](https://developer.mozilla.org/en-US/docs/Web/API/console/log)

---

# 1_variable.js — JavaScript Variables

**Learning Goals:**
- Understand how to declare variables using `var`, `let`, and `const`.
- Know the rules for reassignment and scope.
- Recognize the dangers of implicit global variables.

---

## Overview

Variables are containers for storing data values. JavaScript provides three main ways to declare variables: `var`, `let`, and `const`.

---

## Syntax & Examples

```js
const accountId = 1234;
let accountEmail = "veena@gmail.com";
var accountPassword = "8879-9";
let accountState;
accountCity = "hapur"; // Implicit global (not recommended)

accountEmail = "hfkfds@ngghh";
accountPassword = 77890;
accountCity = "ha";

console.log('accountId:', accountId);
console.log('accountEmail:', accountEmail);
console.log('accountPassword:', accountPassword);
console.log('accountCity:', accountCity);
console.log('accountState:', accountState);
console.table([accountId, accountEmail, accountPassword, accountPassword, accountCity, accountState]);
```

---

## Key Takeaways
> - Use `const` for values that won't change.
> - Use `let` for variables that will be reassigned.
> - Avoid `var` due to function-scoping issues.
> - Always declare variables before using them.
> - Include variable names in console output for clarity.

---

## Common Pitfalls & Warnings
> ⚠️ **Warning:**
> Assigning to undeclared variables creates implicit globals, which can lead to bugs and hard-to-maintain code.

---

## Practice
**Try it yourself:**
- Declare a variable for your favorite color using `let` and print it.
- Try reassigning a `const` variable and observe the error.

**Quiz:**
```js
var x = 10;
if (true) {
  let x = 20;
  console.log(x);
}
console.log(x);
// What does this print?
```

---

## Further Reading
- [MDN: var](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var)
- [MDN: let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)
- [MDN: const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)

---

## Difference Between var, let, and const

**Learning Goals:**
- Compare the differences in scope, hoisting, re-declaration, and reassignment for `var`, `let`, and `const`.
- Learn best practices for choosing variable declarations.

---

### Overview

JavaScript provides three ways to declare variables: `var`, `let`, and `const`. They differ in scope, hoisting, re-declaration, and reassignment rules.

---

### Syntax & Examples

| Feature                | var                                 | let                                 | const                                 |
|------------------------|-------------------------------------|-------------------------------------|---------------------------------------|
| Scope                  | Function or global                  | Block ({}), not global              | Block ({}), not global                |
| Hoisting               | Yes (initialized as undefined)      | Yes (in TDZ until declaration)      | Yes (in TDZ until declaration)        |
| Re-declaration         | Allowed                             | Not allowed in same scope           | Not allowed in same scope             |
| Re-assignment          | Allowed                             | Allowed                             | Not allowed                           |
| Must initialize?       | No                                  | No                                  | Yes                                   |
| Default value          | undefined                           | ReferenceError if accessed early    | ReferenceError if accessed early      |

```js
// var
function exampleVar() {
    var n = "Janardhan";
    console.log(n); // Janardhan
}
exampleVar();
console.log(x); // undefined (hoisted)
var x = 5;
var name = "Pranjal";
var name = "Tanmay"; // re-declaration allowed
console.log(name); // Tanmay

// let
if (true) {
let age = 30;
    console.log(age); // 30
}
// console.log(age); // ReferenceError
console.log(y); // ReferenceError (TDZ)
let y = 10;
let city = 'Delhi';
// let city = 'Mumbai'; // SyntaxError
city = 'Mumbai'; // Allowed

// const
const country = "USA";
console.log(country); // USA
// country = "India"; // TypeError
const city2 = "New York";
// const city2 = "Los Angeles"; // SyntaxError
// const a; // SyntaxError
const numbers = [1, 2, 3];
numbers.push(4); // Allowed
// numbers = [5, 6]; // TypeError
const person = { name: "Alice" };
person.age = 25; // Allowed
// person = { name: "Bob" }; // TypeError
```

---

### Key Takeaways
> - `var` is function/global scoped and hoisted as undefined.
> - `let` and `const` are block scoped and in the temporal dead zone until declared.
> - `const` must be initialized and cannot be reassigned.
> - Prefer `const` for values that never change, `let` for those that do, and avoid `var`.

---

### Common Pitfalls & Warnings
> ⚠️ **Warning:**
> Using `var` can lead to bugs due to hoisting and scope confusion. Accessing `let` or `const` before declaration throws a ReferenceError.

---

### Practice
**Try it yourself:**
- Try redeclaring a variable with `let` in the same scope and observe the error.
- Create a `const` array and try to reassign it vs. modifying its contents.

**Quiz:**
```js
console.log(a);
let a = 5;
// What happens?
```

---

### Further Reading
- [GeeksforGeeks: Difference between var, let and const keywords in JavaScript](https://www.geeksforgeeks.org/javascript/difference-between-var-let-and-const-keywords-in-javascript/)
- [MDN: var, let, const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var)

---

# 2_dataType.js — JavaScript Data Types

**Learning Goals:**
- Identify primitive and non-primitive data types in JavaScript.
- Use `typeof` to check data types.
- Understand quirks like `typeof null`.

---

## Overview

JavaScript is a dynamically typed language with several primitive and non-primitive data types. Strict mode helps catch errors early.

---

## Syntax & Examples

```js
"use strict";
let name = "veenayak"; // String
let age = 22; // Number
let isLogged = false; // Boolean
let state = null; // Null
let city; // Undefined
console.log('typeof age:', typeof age); // "number"
console.log('typeof null:', typeof null); // "object"
console.log('typeof undefined:', typeof undefined); // "undefined"
console.log('city value:', city);
console.log('typeof city:', typeof city);
```

---

## Key Takeaways
> - Use `typeof` to check data types.
> - `null` is a special case that returns "object".
> - Undefined variables have type "undefined".
> - Always declare variables before using them.

---

## Common Pitfalls & Warnings
> ⚠️ **Warning:**
> `typeof null` returns "object" (a JavaScript quirk).

---

## Practice
**Try it yourself:**
- Declare a variable of each primitive type and print its type.
- What does `typeof NaN` return?

**Quiz:**
```js
let x;
console.log(typeof x);
x = null;
console.log(typeof x);
// What does this print?
```

---

## Further Reading
- [MDN: Data types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures)

---

# 3_conversionOperation.js — JavaScript Type Conversion

**Learning Goals:**
- Convert between strings, numbers, booleans, null, and undefined.
- Recognize what results in `NaN` and how to check for it.

---

## Overview

JavaScript automatically converts types when needed (implicit conversion), but you can also convert types explicitly using constructors like `Number()`.

---

## Syntax & Examples

```js
let score = "33";
console.log('typeof score (initial):', typeof score); // string
console.log('typeof Number(score):', typeof Number(score)); // number
score = "33q";
console.log('Number(score):', Number(score)); // NaN
score = null;
console.log('Number(score):', Number(score)); // 0
score = undefined;
console.log('Number(score):', Number(score)); // NaN
let isLoggedIn = true;
console.log('Number(isLoggedIn):', Number(isLoggedIn)); // 1
score = "veenayak";
console.log('Number(score):', Number(score)); // NaN
```

---

## Key Takeaways
> - `Number()` performs explicit type conversion.
> - Invalid conversions result in `NaN`.
> - `typeof NaN` returns "number" (quirk).
> - `null` converts to 0, `undefined` to NaN.

---

## Common Pitfalls & Warnings
> ⚠️ **Warning:**
> Not all strings can be converted to numbers. Always check for `NaN` after conversion.

---

## Practice
**Try it yourself:**
- Convert `"42"`, `"abc"`, `true`, `false`, `null`, and `undefined` to numbers and print the results.

**Quiz:**
```js
console.log(Number(""));
console.log(Number("0"));
console.log(Number(false));
// What does this print?
```

---

## Further Reading
- [MDN: Type Conversion](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#type_conversion)

---

# 4_operation.js — JavaScript Operations

**Learning Goals:**
- Perform arithmetic operations and understand operator precedence.
- Understand type coercion with the `+` operator.
- Use unary and increment/decrement operators correctly.

---

## Overview

JavaScript supports arithmetic, string concatenation, and type coercion. Understanding how operators work and how JavaScript converts types is essential for writing bug-free code.

---

## Syntax & Examples

```js
// Basic Arithmetic
let value = 3;
let negValue = -value;
console.log('negValue:', negValue);
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Concatenation
let str1 = "hello";
let str2 = " veenayak";
let str3 = str1 + str2;
console.log('str3:', str3);
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// Type Coercion with + Operator
console.log("'1' + 2:", '1' + 2); // '12'
console.log("1 + '2':", 1 + "2"); // '12'
console.log("'1' + 2 + 2:", '1' + 2 + 2); // '122'
console.log("1 + 2 + '2':", 1 + 2 + "2"); // '32'
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// Unary Plus for Type Conversion
console.log("Unary plus on true:", +true); // 1
console.log("Unary plus on empty string:", +""); // 0
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// Prefix and Postfix Increment/Decrement
let gameCounter = 100;
console.log("Initial gameCounter:", gameCounter); // 100
let postInc = gameCounter++;
console.log("gameCounter after postfix increment:", gameCounter); // 101
console.log("Value of postInc (gameCounter++):", postInc); // 100
let preInc = ++gameCounter;
console.log("gameCounter after prefix increment:", gameCounter); // 102
console.log("Value of preInc (++gameCounter):", preInc); // 102
console.log('%c==================================================================', 'color: green; font-weight: bold;')
```

---

## Key Takeaways
> - The `+` operator performs string concatenation if either operand is a string.
> - Evaluation of expressions happens from left to right, which is crucial for understanding type coercion with `+`.
> - The unary plus `+` is a concise way to convert a value to a number.
> - Be mindful of the difference between prefix (`++i`) and postfix (`i++`) increment/decrement operators, as they return different values.
> - For clarity and to avoid bugs, it's often better to perform increments on a separate line rather than within a larger expression.

---

## Common Pitfalls & Warnings
> ⚠️ **Warning:**
> Mixing types with the `+` operator can lead to unexpected results due to type coercion. Always check operand types if unsure.

---

## Practice
**Try it yourself:**
- Predict the result of `'5' + 3 + 2` and `3 + 2 + '5'`.
- Use the unary plus to convert a string to a number and add 10.

**Quiz:**
```js
let a = 5;
console.log(a++ + ++a);
// What does this print?
```

---

## Further Reading
- [MDN: Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators)

---

# 5_comparison.js — JavaScript Comparisons

**Learning Goals:**
- Understand equality and relational operators.
- Know the difference between `==` and `===`.
- Learn how `null` and `undefined` behave in comparisons.

---

## Overview

JavaScript provides both loose (`==`) and strict (`===`) equality operators, as well as relational operators. Special care is needed when comparing `null` and `undefined`.

---

## Syntax & Examples

```js
// Comparisons with null
console.log('null > 0:', null > 0); // false
console.log('null == 0:', null == 0); // false
console.log('null >= 0:', null >= 0); // true
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// Comparisons with undefined
console.log('undefined > 0:', undefined > 0); // false
console.log('undefined == 0:', undefined == 0); // false
console.log('undefined >= 0:', undefined >= 0); // false
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// Strict vs Loose Equality
console.log("'2' == 2:", '2' == 2); // true
console.log("'2' === 2:", '2' === 2); // false
```

---

## Key Takeaways
> - Use `===` for equality comparisons (recommended).
> - `null` converts to 0 in relational comparisons, but not in equality.
> - `undefined` converts to NaN in all comparisons.
> - Be aware of type coercion in loose equality.

---

## Common Pitfalls & Warnings
> ⚠️ **Warning:**
> Using `==` can lead to unexpected results due to type coercion. Always prefer `===` unless you have a specific reason.

---

## Practice
**Try it yourself:**
- Compare `null` and `undefined` with `==` and `===`.
- Predict the result of `'0' == 0` and `'0' === 0`.

**Quiz:**
```js
console.log(null >= 0);
console.log(undefined == 0);
// What does this print?
```

---

## Further Reading
- [MDN: Equality comparisons and sameness](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness)

---

# 6_strings.js — JavaScript Strings

**Learning Goals:**
- Use template literals and string interpolation.
- Access and manipulate string properties and methods.
- Understand string immutability and method differences.

---

## Overview

Strings are sequences of characters used to represent text. JavaScript provides many methods for manipulating and inspecting strings.

---

## Syntax & Examples

```js
// Template Literals
let name = "veenayak";
let repoCount = 50;
console.log('Template literal:', `hello my name is ${name} and my repo count is ${repoCount}`);
console.log('Backticks example:', `Backticks`);
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Access by Index
console.log('name[0]:', name[0]);
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Constructors
let userName = String("Veenayak");
let userGame = new String("Veenayak");
console.table([name, userName, userGame]);
console.log('%c==================================================================', 'color: green; font-weight: bold;')
console.log('userGame.__proto__:', userGame.__proto__);
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Properties
console.log('userGame.length:', userGame.length);
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Methods - Case Conversion
console.log('userGame.toUpperCase():', userGame.toUpperCase());
console.log('userGame.toLowerCase():', userGame.toLowerCase());
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Methods - Character Access
console.log('userGame.charAt(2):', userGame.charAt(2));
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Methods - Search and Index
console.log('userGame.indexOf("e"):', userGame.indexOf('e'));
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Methods - Substring Extraction
const neu = userGame.substring(0, 4);
console.log('neu (substring 0,4):', neu);
console.log('%c==================================================================', 'color: green; font-weight: bold;')
const news = userGame.slice(-6, 4);
console.log('news (slice -6,4):', news);
console.log('%c==================================================================', 'color: green; font-weight: bold;')
const newss = userGame[2, 4];
console.log('newss (incorrect syntax):', newss);
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Methods - Whitespace and Cleaning
const nam = "       veenayak        ";
console.log('nam (with spaces):', nam);
console.log('nam.trim():', nam.trim());
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Methods - Replacement
const url = "http://veenayak%20sirohi";
console.log('url.replace("%20","-"):', url.replace('%20', '-'));
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Methods - Search and Check
console.log('url.includes("sirohi"):', url.includes("sirohi"));
console.log('url.includes("hi"):', url.includes("hi"));
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Methods - Prefix and Suffix
console.log('userGame.startsWith("Vee"):', userGame.startsWith("Vee"));
console.log('userGame.startsWith("vee"):', userGame.startsWith("vee"));
console.log('userGame.endsWith("yak"):', userGame.endsWith("yak"));
console.log('userGame.endsWith("Yak"):', userGame.endsWith("Yak"));
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Methods - Splitting and Joining
const fullName = "Veenayak Sirohi";
console.log('fullName.split(" "):', fullName.split(" "));
console.log('fullName.split(""):', fullName.split(""));
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// String Methods - Repetition
console.log('"Ha".repeat(3):', "Ha".repeat(3));
console.log('%c==================================================================', 'color: green; font-weight: bold;')
```

---

## Key Takeaways
> - Use template literals for string interpolation.
> - String() creates primitives, new String() creates objects.
> - Strings are zero-indexed.
> - Most string methods return new strings (immutable).
> - Be careful with string method syntax differences.

---

## Common Pitfalls & Warnings
> ⚠️ **Warning:**
> Using `new String()` creates a String object, not a primitive. Most of the time, you want a primitive string.
> Some string methods behave differently (e.g., `substring` vs. `slice`).

---

## Practice
**Try it yourself:**
- Use `slice` and `substring` to extract parts of a string and compare the results.
- Try using `trim()`, `replace()`, and `repeat()` on your own strings.

**Quiz:**
```js
let s = "JavaScript";
console.log(s.slice(1, 4));
console.log(s.substring(1, 4));
// What does this print?
```

---

## Further Reading
- [MDN: String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)

---

# 7_numberMath.js — JavaScript Numbers and Math

**Learning Goals:**
- Create and use numbers in JavaScript.
- Use built-in number methods for formatting and conversion.
- Perform mathematical operations with the Math object.
- Generate random numbers and understand floating-point quirks.

---

## Overview

JavaScript supports both primitive numbers and Number objects. The Math object provides a wide range of mathematical functions and constants. Understanding number methods and random number generation is essential for many programming tasks.

---

## Syntax & Examples

```js
// Number Creation and Types
const score = 400;
console.log('score (primitive):', score);
console.log('%c==================================================================', 'color: green; font-weight: bold;')
const balance = new Number(100);
console.log('balance (Number object):', balance);
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// Number Methods
console.log('balance.toString().length:', balance.toString().length);
console.log('balance.toFixed(1):', balance.toFixed(1));
const otherNumber = 123.8966;
console.log('otherNumber.toPrecision(4):', otherNumber.toPrecision(4));
const hundreds = 1000000;
console.log('hundreds.toLocaleString("en-IN"):', hundreds.toLocaleString('en-IN'));
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// Math Object
console.log('Math object:', Math);
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// Math Methods - Basic Operations
console.log('Math.abs(-4):', Math.abs(-4));
console.log('Math.round(4.6):', Math.round(4.6));
console.log('Math.ceil(4.2):', Math.ceil(4.2));
console.log('Math.floor(4.9):', Math.floor(4.9));
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// Math Methods - Min/Max Operations
console.log('Math.min(4, 3, 6, 8):', Math.min(4, 3, 6, 8));
console.log('Math.max(4, 3, 6, 8):', Math.max(4, 3, 6, 8));
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// Random Number Generation
console.log('Math.random():', Math.random());
console.log('(Math.random() * 10) + 1:', (Math.random() * 10) + 1);
console.log('Math.floor(Math.random() * 10) + 1:', Math.floor(Math.random() * 10) + 1);
console.log('%c==================================================================', 'color: green; font-weight: bold;')

// Random Number in Range
const min = 10;
const max = 20;
console.log('Random between 10-20:', Math.floor(Math.random() * (max - min + 1)) + min);
console.log('%c==================================================================', 'color: green; font-weight: bold;')
```

---

## Key Takeaways
> - Use primitive numbers for simple calculations.
> - Number objects are rarely needed.
> - Math methods are static (call directly on Math object).
> - Random numbers are pseudo-random, not cryptographically secure.
> - Be aware of floating-point precision issues.

---

## Common Pitfalls & Warnings
> ⚠️ **Warning:**
> Floating-point arithmetic can lead to unexpected results (e.g., `0.1 + 0.2 !== 0.3`). Always check for precision issues when comparing decimals.

---

## Practice
**Try it yourself:**
- Format a number to two decimal places using `toFixed()`.
- Generate a random integer between 5 and 15.

**Quiz:**
```js
console.log(0.1 + 0.2 === 0.3);
// What does this print?
```

---

## Further Reading
- [MDN: Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)
- [MDN: Math](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math)

---

# 8_dates.js — JavaScript Dates

**Learning Goals:**
- Create and manipulate Date objects.
- Format dates and extract components.
- Work with timestamps and custom date formatting.

---

## Overview

JavaScript's Date object allows you to work with dates and times. You can create dates, extract components, and format them for display. Understanding how to use Date methods is essential for time-based applications.

---

## Syntax & Examples

```js
// Date Creation and Basic Operations
let myDate = new Date();

// Date String Representations
console.log('myDate.toString():', myDate.toString());
console.log('myDate.toDateString():', myDate.toDateString());
console.log('myDate.toLocaleString():', myDate.toLocaleString());
console.log('Type of myDate:', typeof myDate);

// Creating Specific Dates
let myCreatedDate = new Date(2023, 0, 23);
console.log('myCreatedDate (YYYY, M, D):', myCreatedDate.toDateString());
let myCreatedDateWithTime = new Date(2023, 0, 23, 5, 3);
console.log('myCreatedDateWithTime (with time):', myCreatedDateWithTime.toLocaleString());

// Creating Dates from Strings
let myCreatedDateFromString1 = new Date("2023-01-14");
console.log('myCreatedDateFromString1 (YYYY-MM-DD):', myCreatedDateFromString1.toLocaleString());
let myCreatedDateFromString2 = new Date("01-14-2023");
console.log('myCreatedDateFromString2 (MM-DD-YYYY):', myCreatedDateFromString2.toLocaleString());

// Timestamps
let myTimeStamp = Date.now();
console.log('myTimeStamp (ms since epoch):', myTimeStamp);
console.log('myCreatedDate.getTime() (ms since epoch):', myCreatedDate.getTime());
console.log('Date.now() in seconds:', Math.floor(Date.now() / 1000));

// Getting Date Components
let newDate = new Date();
console.log('newDate:', newDate);
console.log('newDate.getMonth() + 1:', newDate.getMonth() + 1);
console.log('newDate.getDay():', newDate.getDay());
console.log('newDate.getFullYear():', newDate.getFullYear());

// Custom Date Formatting
let customDate = newDate.toLocaleString('default', {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
});
console.log('Custom formatted date:', customDate);
```

---

## Key Takeaways
> - Date constructor creates Date objects.
> - Months are 0-indexed (0 = January, 11 = December).
> - Timestamps are milliseconds since Unix Epoch.
> - Date objects are mutable.
> - Use toLocaleString() for user-friendly formatting.

---

## Common Pitfalls & Warnings
> ⚠️ **Warning:**
> Months are zero-indexed, so January is 0 and December is 11. Always add 1 when displaying months to users.

---

## Practice
**Try it yourself:**
- Create a date for your birthday and print it in a readable format.
- Extract the year, month, and day from the current date.

**Quiz:**
```js
let d = new Date("2022-12-31");
console.log(d.getMonth());
// What does this print?
```

---

## Further Reading
- [MDN: Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)

---

# 9_array.js — JavaScript Arrays

**Learning Goals:**
- Create, access, and modify arrays using various methods (literal, constructor, Array.of, Array.from).
- Use array methods for searching, extracting, combining, and flattening data.
- Understand the difference between mutating and non-mutating methods.
- Iterate over arrays using different loop constructs and array methods.
- Work with array-like objects and convert them to arrays.
- Use array destructuring and default values.
- Handle multidimensional and nested arrays.
- Apply best practices and avoid common pitfalls.

---

## Overview

Arrays are ordered collections of values. JavaScript provides many methods for manipulating arrays, searching, combining, and flattening them. Understanding array methods and iteration is key to effective data processing and clean code.

---

## Syntax & Examples

### Array Creation

#### 1. Array Literal
```js
const fruits = ['apple', 'banana', 'cherry'];
console.log({ fruits });
```

#### 2. Array Constructor
```js
const arr = new Array(3); // [empty × 3]
const arr2 = new Array('a', 'b', 'c');
console.log({ arr, arr2 });
```

#### 3. Array.of
```js
const numbers = Array.of(1, 2, 3);
console.log({ numbers });
```

#### 4. Array.from
```js
const str = 'hello';
const chars = Array.from(str);
console.log({ chars });
const arrLike = { 0: 'a', 1: 'b', length: 2 };
const realArr = Array.from(arrLike);
console.log({ realArr });
```

### Accessing and Modifying Elements
```js
const colors = ['red', 'green', 'blue'];
console.log('colors[1]:', colors[1]);
colors[2] = 'yellow';
console.log({ colors });
colors[5] = 'purple'; // creates empty slots
console.log({ colors });
```

### Mutating vs Non-Mutating Methods

#### Mutating Methods
```js
const nums = [1, 2, 3];
nums.push(4); // [1,2,3,4]
nums.pop();   // [1,2,3]
nums.shift(); // [2,3]
nums.unshift(0); // [0,2,3]
nums.splice(1, 1, 9); // [0,9,3]
console.log({ nums });
```

#### Non-Mutating Methods
```js
const letters = ['a', 'b', 'c'];
const newLetters = letters.concat(['d', 'e']);
const sliced = letters.slice(1, 3);
console.log({ letters, newLetters, sliced });
```

### Searching and Checking
```js
const animals = ['cat', 'dog', 'bat'];
console.log('animals.includes("dog"):', animals.includes('dog'));
console.log('animals.indexOf("bat"):', animals.indexOf('bat'));
```

### Extraction and Combination
```js
const arr1 = [1, 2];
const arr2 = [3, 4];
const combined = arr1.concat(arr2);
const spreadCombined = [...arr1, ...arr2];
console.log({ combined, spreadCombined });
```

### Flattening Arrays
```js
const nested = [1, [2, [3, 4]]];
const flat1 = nested.flat(); // [1,2,[3,4]]
const flat2 = nested.flat(2); // [1,2,3,4]
console.log({ flat1, flat2 });
```

### Utility Methods
```js
const arr3 = [1, 2, 3];
console.log('Array.isArray(arr3):', Array.isArray(arr3));
console.log('arr3.join("-"):', arr3.join('-'));
console.log('arr3.toString():', arr3.toString());
```

### Iteration

#### for Loop
```js
const nums2 = [10, 20, 30];
for (let i = 0; i < nums2.length; i++) {
  console.log('nums2[i]:', nums2[i]);
}
```

#### for...of Loop
```js
for (const value of nums2) {
  console.log('for...of value:', value);
}
```

#### forEach
```js
nums2.forEach((item, idx) => {
  console.log('forEach item:', item, 'index:', idx);
});
```

#### map
```js
const squares = nums2.map(n => n * n);
console.log({ squares });
```

#### filter
```js
const even = nums2.filter(n => n % 2 === 0);
console.log({ even });
```

#### reduce
```js
const sum = nums2.reduce((acc, n) => acc + n, 0);
console.log({ sum });
```

### Array-like Objects and Conversion
```js
function argsToArray() {
  console.log('arguments:', arguments);
  const arr = Array.from(arguments);
  console.log({ arr });
}
argsToArray(1, 2, 3);
```

### Destructuring Arrays
```js
const [first, second, ...rest] = [1, 2, 3, 4];
console.log({ first, second, rest });
```

### Multidimensional and Nested Arrays
```js
const matrix = [
  [1, 2],
  [3, 4]
];
console.log('matrix[1][0]:', matrix[1][0]);
```

---

## Comparison Table: Array Methods
| Method      | Mutates? | Returns New? | Use Case                        |
|-------------|----------|--------------|---------------------------------|
| push/pop    | Yes      | No           | Add/remove end                  |
| shift/unshift| Yes     | No           | Add/remove start                |
| splice      | Yes      | No           | Add/remove/replace anywhere     |
| slice       | No       | Yes          | Extract subarray                |
| concat      | No       | Yes          | Combine arrays                  |
| map         | No       | Yes          | Transform elements              |
| filter      | No       | Yes          | Filter elements                 |
| reduce      | No       | Yes (single) | Aggregate to single value       |
| forEach     | No       | No           | Side effects, iteration         |
| flat        | No       | Yes          | Flatten nested arrays           |
| join        | No       | Yes (string) | Combine to string               |

---

## Real-World Use Cases
- **Data transformation:**
  ```js
  const users = [
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' }
  ];
  const names = users.map(u => u.name);
  console.log({ names });
  ```
- **Filtering data:**
  ```js
  const adults = users.filter(u => u.age >= 18);
  ```
- **Summing values:**
  ```js
  const total = [10, 20, 30].reduce((sum, n) => sum + n, 0);
  console.log({ total });
  ```
- **Flattening nested arrays:**
  ```js
  const deep = [1, [2, [3, 4]]];
  const flat = deep.flat(2);
  console.log({ flat });
  ```
- **Converting arguments to array:**
  ```js
  function f() { return Array.from(arguments); }
  ```

---

## Key Takeaways
> - Use array literals for most cases.
> - Prefer non-mutating methods for functional programming.
> - Use spread (`...`) and `Array.from` for copying and conversion.
> - Use `map`, `filter`, `reduce` for data processing.
> - Always check if a variable is an array with `Array.isArray()`.
> - Be careful with sparse arrays and empty slots.

---

## Common Pitfalls & Warnings
> ⚠️ **Warning:**
> - Mutating methods change the original array—avoid if you need immutability.
> - `for...in` iterates over all enumerable properties, not just indices—use `for...of` or classic for for arrays.
> - Sparse arrays (with empty slots) can cause unexpected behavior in iteration and methods.
> - `Array.from` and spread only do shallow copies.
> - `==` does not compare array contents, only references.

---

## Practice
**Try it yourself:**
- Create an array of your three favorite foods and print its length.
- Use `slice()` and `splice()` to extract elements and observe the difference.
- Use `map` to double each value in an array.
- Use `filter` to select only odd numbers from an array.
- Use `reduce` to sum an array of numbers.

**Quiz:**
```js
let arr = [1, 2, 3, 4, 5];
let x = arr.slice(1, 3);
let y = arr.splice(1, 3);
console.log(arr);
// What does this print?
```

---

## Further Reading
- [MDN: Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
- [MDN: Array methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#instance_methods)
- [Jake Worth: Logging an Object in JavaScript](https://www.jakeworth.com/posts/logging-an-object/)

---

# 10_objects.js — JavaScript Objects

**Learning Goals:**
- Create and access object properties using various methods (literal, constructor, Object.create).
- Use Symbols and computed property names as object keys.
- Understand property descriptors, immutability (`Object.freeze`, `Object.seal`).
- Define and call object methods, and understand `this` binding (including arrow function pitfalls).
- Work with nested objects and arrays of objects.
- Use utility methods (`Object.keys`, `Object.values`, `Object.entries`, `hasOwnProperty`, etc.).
- Merge and clone objects (shallow vs deep copy).
- Use destructuring and default values.
- Iterate over objects (for...in, Object.entries, caveats).
- Apply best practices and avoid common pitfalls.

---

## Overview

Objects are key-value collections used to represent structured data. JavaScript objects can have properties, methods, and support advanced features like symbols, immutability, and destructuring. Mastering objects is essential for effective JavaScript programming.

---

## Syntax & Examples

### Object Creation

#### 1. Object Literal
```js
const user = {
  name: 'veenayak',
  age: 22,
  email: 'veena@edv.com',
  'favorite color': 'blue', // property with space
};
console.log({ user });
```

#### 2. Object Constructor
```js
const obj = new Object();
obj.name = 'Pranjal';
obj.age = 25;
console.log({ obj });
```

#### 3. Object.create
```js
const proto = { greet() { return 'Hello!'; } };
const child = Object.create(proto);
child.name = 'Tanmay';
console.log({ child });
console.log('child.greet():', child.greet());
```

### Property Access

#### Dot Notation
```js
console.log('user.name:', user.name);
```

#### Bracket Notation (for dynamic or special keys)
```js
console.log('user["favorite color"]:', user['favorite color']);
const key = 'email';
console.log('user[key]:', user[key]);
```

#### Computed Property Names
```js
const prop = 'score';
const player = { [prop]: 100 };
console.log({ player });
```

#### Symbol Properties
```js
const sym = Symbol('id');
const objWithSym = { [sym]: 123 };
console.log('objWithSym[sym]:', objWithSym[sym]);
```

### Property Descriptors & Immutability

#### Object.freeze
```js
const frozen = { a: 1 };
Object.freeze(frozen);
frozen.a = 2; // Ignored in non-strict mode
console.log({ frozen });
```

#### Object.seal
```js
const sealed = { b: 2 };
Object.seal(sealed);
sealed.b = 3; // Allowed
sealed.c = 4; // Not added
console.log({ sealed });
```

#### Defining Property Descriptors
```js
const descObj = {};
Object.defineProperty(descObj, 'hidden', {
  value: 42,
  writable: false,
  enumerable: false,
  configurable: false
});
console.log('descObj.hidden:', descObj.hidden);
console.log('Object.keys(descObj):', Object.keys(descObj)); // 'hidden' not listed
```

### Methods & `this`

#### Regular Method
```js
const person = {
  name: 'Alice',
  greet() {
    return `Hello, my name is ${this.name}`;
  }
};
console.log('person.greet():', person.greet());
```

#### Arrow Function Pitfall
```js
const badPerson = {
  name: 'Bob',
  greet: () => `Hi, I'm ${this.name}` // 'this' is not bound to badPerson
};
console.log('badPerson.greet():', badPerson.greet()); // undefined
```

### Nested Objects & Arrays of Objects
```js
const company = {
  name: 'TechCorp',
  address: {
    city: 'Delhi',
    zip: '110001'
  },
  employees: [
    { id: 1, name: 'A' },
    { id: 2, name: 'B' }
  ]
};
console.log({ company });
console.log('company.address.city:', company.address.city);
console.log('company.employees[1].name:', company.employees[1].name);
```

### Object Utility Methods
```js
const utilObj = { x: 1, y: 2 };
console.log('Object.keys(utilObj):', Object.keys(utilObj));
console.log('Object.values(utilObj):', Object.values(utilObj));
console.log('Object.entries(utilObj):', Object.entries(utilObj));
console.log('utilObj.hasOwnProperty("x"):', utilObj.hasOwnProperty('x'));
```

### Merging & Cloning Objects

#### Shallow Copy
```js
const o1 = { a: 1 };
const o2 = { b: 2 };
const merged = { ...o1, ...o2 };
console.log({ merged });
const clone = Object.assign({}, o1);
console.log({ clone });
```

#### Deep Copy (using JSON, for simple objects)
```js
const deep = { nested: { value: 5 } };
const deepClone = JSON.parse(JSON.stringify(deep));
deep.nested.value = 10;
console.log('deepClone.nested.value:', deepClone.nested.value); // 5
```

### Destructuring & Default Values
```js
const settings = { theme: 'dark', fontSize: 16 };
const { theme, fontSize, language = 'en' } = settings;
console.log({ theme, fontSize, language });
```

### Iteration

#### for...in (keys)
```js
const iterObj = { a: 1, b: 2 };
for (const key in iterObj) {
  if (Object.hasOwn(iterObj, key)) {
    console.log('key:', key, 'value:', iterObj[key]);
  }
}
```

#### Object.entries (keys & values)
```js
Object.entries(iterObj).forEach(([key, value]) => {
  console.log('entry:', key, value);
});
```

---

## Comparison Table: Object Features & Methods
| Feature/Method         | Description                                 | Example/Notes                       |
|-----------------------|---------------------------------------------|-------------------------------------|
| Literal               | Quickest way to create objects              | `{ a: 1 }`                          |
| Constructor           | `new Object()`                              | Rarely used                         |
| Object.create         | Create with prototype                       | `Object.create(proto)`              |
| Dot/Bracket Notation  | Access properties                           | `obj.x`, `obj['x']`                 |
| Symbol Key            | Unique, non-enumerable property             | `obj[Symbol('id')] = 1`             |
| Object.freeze         | Make object immutable                       | `Object.freeze(obj)`                |
| Object.seal           | Prevent adding/removing props               | `Object.seal(obj)`                  |
| Object.keys/values    | Get keys/values as array                    | `Object.keys(obj)`                  |
| Object.entries        | Get [key, value] pairs                      | `Object.entries(obj)`               |
| Object.assign/spread  | Shallow merge/clone                         | `{ ...a, ...b }`                    |
| JSON methods          | Deep clone (simple objects only)             | `JSON.parse(JSON.stringify(obj))`   |
| Destructuring         | Extract properties                          | `const {x} = obj`                   |
| for...in              | Iterate keys (own + inherited)              | Use `hasOwnProperty` to filter      |
| Object.hasOwn         | Check own property (ES2022+)                | `Object.hasOwn(obj, key)`           |

---

## Real-World Use Cases
- **Configuration objects:**
  ```js
  const config = { debug: true, apiUrl: '/api' };
  ```
- **Data modeling:**
  ```js
  const user = { id: 1, name: 'Alice', roles: ['admin', 'user'] };
  ```
- **Grouping related functions:**
  ```js
  const math = {
    add(a, b) { return a + b; },
    sub(a, b) { return a - b; }
  };
  ```
- **Mapping IDs to values:**
  ```js
  const lookup = { 1: 'one', 2: 'two' };
  ```
- **Encapsulation (module pattern):**
  ```js
  const counter = (function() {
    let count = 0;
    return {
      inc() { count++; },
      get() { return count; }
    };
  })();
  ```

---

## Key Takeaways
> - Use object literals for most cases.
> - Use dot notation for known keys, bracket for dynamic/special keys.
> - Use `Object.freeze`/`Object.seal` for immutability.
> - Arrow functions do not bind `this`—avoid as object methods.
> - Use spread or `Object.assign` for shallow copies; use libraries for deep cloning.
> - Use destructuring for cleaner code.
> - Always check for own properties in for...in loops.

---

## Common Pitfalls & Warnings
> ⚠️ **Warning:**
> - Arrow functions do not bind `this`—do not use as object methods if you need `this`.
> - `Object.freeze`/`Object.seal` only affect the first level (shallow).
> - Using for...in on arrays iterates over indices as strings (not recommended).
> - Symbol properties are not included in `Object.keys`/`Object.entries`.
> - Deep cloning with JSON methods fails for functions, symbols, and non-JSON-safe values.

---

## Practice
**Try it yourself:**
- Create an object with a method that uses `this` and call it.
- Merge two objects using both `Object.assign` and the spread operator.
- Use destructuring to extract a property from an object and provide a default value.
- Iterate over an object's own properties and print keys and values.

**Quiz:**
```js
const obj = { a: 1 };
Object.freeze(obj);
obj.a = 2;
console.log(obj.a);
// What does this print?
```

---

## Further Reading
- [MDN: Objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
- [MDN: Object Destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)
- [Jake Worth: Logging an Object in JavaScript](https://www.jakeworth.com/posts/logging-an-object/)
- [MDN: Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)
- [MDN: Object.seal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)
- [MDN: Object.create](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
- [MDN: for...in](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)

---

# 11_function_and_parameter.js — JavaScript Functions and Parameters

**Learning Goals:**
- Declare and call functions with and without parameters.
- Understand return values and side effects.
- Use rest parameters and handle variable arguments.
- Work with object parameters and destructuring.
- Understand scope, closures, and hoisting.
- Know the differences between function types and parameter handling.

---

## Overview

Functions are reusable blocks of code that perform specific tasks. JavaScript functions can take parameters, return values, and support advanced features like rest parameters, closures, and destructuring. Understanding function types, parameter handling, and scope is essential for writing maintainable code.

---

## Syntax & Examples

### 1. Function Declaration (Named Function)
**Syntax:**
```js
function greet(name) {
  return `Hello, ${name}!`;
}
console.log(greet('Alice'));
```
- Hoisted (can be called before definition)

### 2. Function Expression
**Syntax:**
```js
const add = function(a, b) {
  return a + b;
};
console.log(add(2, 3));
```
- Not hoisted (cannot be called before definition)

### 3. Arrow Function Expression
**Syntax:**
```js
const square = x => x * x;
console.log(square(4));
```
- No own `this` or `arguments`

### 4. Anonymous Function
**Syntax:**
```js
setTimeout(function() {
  console.log('Timeout!');
}, 1000);
```

### 5. Parameters and Arguments
- **Required parameters:**
  ```js
  function sum(a, b) { return a + b; }
  sum(1, 2); // 3
  ```
- **Optional parameters:**
  ```js
  function log(message, level) {
    if (level) {
      console.log(`[${level}] ${message}`);
    } else {
      console.log(message);
    }
  }
  log('Hello');
  log('Warning!', 'WARN');
  ```
- **Default parameters:**
  ```js
  function multiply(a, b = 2) {
    return a * b;
  }
  console.log(multiply(5)); // 10
  ```
- **Rest parameters:**
  ```js
  function sumAll(...nums) {
    return nums.reduce((acc, n) => acc + n, 0);
  }
  console.log(sumAll(1, 2, 3, 4)); // 10
  ```
- **Destructuring parameters:**
  ```js
  function printUser({ name, age }) {
    console.log(`${name} is ${age} years old.`);
  }
  printUser({ name: 'Bob', age: 30 });
  ```

### 6. Return Values and Side Effects
- **Return value:**
  ```js
  function double(x) { return x * 2; }
  console.log(double(4)); // 8
  ```
- **Side effect:**
  ```js
  function logMessage(msg) { console.log(msg); }
  logMessage('Hello!');
  ```

### 7. Scope and Closures
- **Function scope:**
  ```js
  function outer() {
    let outerVar = 'I am outer';
    function inner() {
      console.log(outerVar); // Can access outerVar
    }
    inner();
  }
  outer();
  ```
- **Closure:**
  ```js
  function makeCounter() {
    let count = 0;
    return function() {
      count++;
      return count;
    };
  }
  const counter = makeCounter();
  console.log(counter()); // 1
  console.log(counter()); // 2
  ```

### 8. Hoisting
- **Function declarations are hoisted:**
  ```js
  console.log(foo()); // 'bar'
  function foo() { return 'bar'; }
  ```
- **Function expressions are not hoisted:**
  ```js
  // console.log(bar()); // Error
  const bar = function() { return 'baz'; };
  ```

---

## Comparison Table: Function Types
| Feature                | Declaration         | Expression           | Arrow Function      |
|------------------------|--------------------|----------------------|--------------------|
| Syntax                 | `function foo(){}` | `const foo = ...`    | `const foo = ...`  |
| Hoisted                | Yes                | No                   | No                 |
| `this` binding         | Dynamic            | Dynamic              | Lexical            |
| `arguments` object     | Yes                | Yes                  | No                 |
| Can be constructor     | Yes                | Yes                  | No                 |
| Use as method          | Yes                | Yes                  | Not recommended    |
| Use as callback        | Yes                | Yes                  | Yes                |

---

## Real-World Use Cases
- **Callbacks:**
  ```js
  [1, 2, 3].forEach(function(n) { console.log(n); });
  [1, 2, 3].forEach(n => console.log(n));
  ```
- **Event handlers:**
  ```js
  button.addEventListener('click', function() { alert('Clicked!'); });
  ```
- **Factory functions:**
  ```js
  function createUser(name) {
    return { name };
  }
  ```
- **Closures for private state:**
  ```js
  function secretHolder(secret) {
    return {
      getSecret: () => secret
    };
  }
  const holder = secretHolder('shh!');
  console.log(holder.getSecret());
  ```

---

## Key Takeaways
> - Use function declarations for reusable logic and when hoisting is needed.
> - Use function expressions and arrow functions for callbacks and inline logic.
> - Use default, rest, and destructuring parameters for flexible APIs.
> - Closures allow functions to remember their outer scope.
> - Arrow functions do not have their own `this` or `arguments`.

---

## Common Pitfalls & Warnings
> ⚠️ **Warning:**
> - Forgetting to return a value results in `undefined`.
> - Hoisting only applies to function declarations, not expressions.
> - Arrow functions are not suitable as constructors or methods needing dynamic `this`.
> - Be careful with parameter order: required, then optional/default, then rest.

---

## Practice
**Try it yourself:**
- Write a function that multiplies two numbers and returns the result.
- Use rest parameters to sum any number of arguments.
- Demonstrate closure by writing a function that returns another function.
- Use destructuring in function parameters.

**Quiz:**
```js
function foo(a, b = 2, ...rest) {
  return a + b + rest.length;
}
console.log(foo(1, 2, 3, 4));
// What does this print?
```


---

## Further Reading
- [MDN: Functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions)
- [MDN: Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
- [MDN: Function parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters)
- [MDN: Arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

---

# 12_arrow_function.js — JavaScript Arrow Functions

**Learning Goals:**
- Use arrow function syntax for concise function expressions.
- Understand the difference in `this` binding between arrow and regular functions.
- Use arrow functions for callbacks and short functions.
- Know when **not** to use arrow functions (e.g., as methods or constructors).

---

## Overview

Arrow functions provide a shorter syntax for writing functions and do not have their own `this`, `arguments`, `super`, or `new.target` bindings. They are ideal for callbacks, array methods, and simple operations, but are not suitable for all use cases.

---

## Syntax & Examples

### Basic Syntax
- **Single parameter, implicit return:**
  ```js
  const square = x => x * x;
  console.log(square(5)); // 25
  ```
- **Multiple parameters:**
  ```js
  const add = (a, b) => a + b;
  console.log(add(2, 3)); // 5
  ```
- **No parameters:**
  ```js
  const greet = () => console.log('Hello!');
  greet(); // Hello!
  ```
- **Block body (explicit return):**
  ```js
  const sum = (a, b) => {
    const result = a + b;
    return result;
  };
  console.log(sum(2, 3)); // 5
  ```

### Arrow Functions and `this`
Arrow functions do **not** have their own `this`. They inherit `this` from the enclosing (lexical) scope.

```js
const obj = {
  value: 42,
  regular: function() { return this.value; },
  arrow: () => this.value
};
console.log(obj.regular()); // 42
console.log(obj.arrow());   // undefined (or window.value in browser)
```

**Use case: Preserving `this` in callbacks**
```js
function Timer() {
  this.seconds = 0;
  setInterval(() => {
    this.seconds++;
    console.log(this.seconds);
  }, 1000);
}
new Timer(); // Correctly increments seconds
```

### Arrow Functions and `arguments`
Arrow functions do **not** have their own `arguments` object.
```js
function regular() {
  return arguments[0];
}
const arrow = () => arguments[0]; // ReferenceError: arguments is not defined
```

### Arrow Functions and Constructors
Arrow functions **cannot** be used as constructors and will throw an error if used with `new`.
```js
const ArrowPerson = (name) => { this.name = name; };
const p2 = new ArrowPerson('Bob'); // TypeError: ArrowPerson is not a constructor
```

### Arrow Functions and call/apply/bind
Arrow functions ignore `this` passed via `call`, `apply`, or `bind`.
```js
const obj = { num: 100 };
globalThis.num = 42;
const add = (a, b, c) => this.num + a + b + c;
console.log(add.call(obj, 1, 2, 3)); // 48 (uses globalThis.num, not obj.num)
```

### Arrow Functions in Array Methods
```js
const arr = [1, 2, 3];
const squares = arr.map(x => x * x);
console.log(squares); // [1, 4, 9]
```

### Arrow Functions in Promises and Callbacks
```js
fetch('/api/data')
  .then(response => response.json())
  .then(data => console.log(data));
```

---

## When **Not** to Use Arrow Functions
- As object methods (if you need `this` to refer to the object)
- As constructors (with `new`)
- When you need the `arguments` object
- As generator functions (cannot use `function*` syntax)
- As event handlers if you need `this` to refer to the element

---

## Best Practices \& Common Pitfalls
- Use arrow functions for short, simple functions and callbacks.
- Do **not** use arrow functions as object methods or constructors.
- Remember that arrow functions do not have their own `this` or `arguments`.
- Prefer regular functions when you need dynamic `this` or access to `arguments`.
- Arrow functions are always anonymous (no `name` property unless assigned).

---

## Comparison Table: Arrow Functions vs Regular Functions

| Feature                | Regular Function                | Arrow Function                  |
|------------------------|---------------------------------|---------------------------------|
| Syntax                 | function keyword                | `=>` arrow syntax               |
| `this` binding         | Dynamic (depends on call site)  | Lexical (inherits from parent)  |
| `arguments` object     | Available                       | Not available                   |
| Constructor            | Can be used with `new`          | Cannot be used as constructor   |
| Generator              | Can be a generator (`function*`)| Cannot be a generator           |
| Prototype              | Has `prototype` property        | No `prototype` property         |
| Use as method          | Suitable                        | Not recommended                 |
| Use as callback        | Suitable                        | Suitable                        |

---

## Real-World Use Cases
- Array methods: `map`, `filter`, `reduce`, `forEach`
- Promise chains: `.then()`, `.catch()`, `.finally()`
- Event listeners (if you do not need `this`)
- Closures where you want to preserve the outer `this`

---

## Key Takeaways
> - Arrow functions are concise and inherit `this` from their enclosing scope.
> - Do not use arrow functions as object methods or constructors.
> - Arrow functions do not have their own `arguments` object.
> - Use arrow functions for callbacks, array methods, and simple logic.

---

## Common Pitfalls \& Warnings
> ⚠️ **Warning:**
> - Arrow functions do not have their own `this`, `arguments`, `super`, or `new.target`.
> - Do not use arrow functions as object methods if you need `this` to refer to the object.
> - Cannot be used as constructors or generators.
> - Cannot use `yield` inside arrow functions.

---

## Practice
**Try it yourself:**
- Convert a regular function to an arrow function.
- Write an arrow function that returns the square of a number.
- Use an arrow function in a `map` or `filter` call.
- Try using `this` inside an arrow function as an object method and observe the result.

**Quiz:**
```js
const obj = {
  value: 10,
  getValue: () => this.value
};
console.log(obj.getValue());
// What does this print?
```

---

## Further Reading
- [MDN: Arrow Functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

---

# 13_Immediately_Invoked_Function_Expressions_(IIFE).js — Immediately Invoked Function Expressions (IIFE)

**Learning Goals:**
- Understand what IIFEs are and why they are used in JavaScript.
- Learn the syntax for both named and anonymous IIFEs.
- Recognize use cases for IIFEs, such as scope isolation and immediate execution.
- Know best practices and common pitfalls when using IIFEs.

---

## Overview

An **Immediately Invoked Function Expression (IIFE)** is a function that is defined and executed immediately after its creation. IIFEs are commonly used to create isolated scopes, avoid polluting the global namespace, and execute code right away. They were especially important before ES6 introduced `let`, `const`, and modules, but are still useful for certain patterns.

---

## Syntax & Examples

### Classic IIFE Syntax
- **Anonymous IIFE:**
  ```js
  (function() {
    console.log('IIFE executed!');
  })();
  ```
- **Named IIFE:**
  ```js
  (function chai() {
    console.log('chai IIFE - DB CONNECTED');
  })();
  ```
- **Arrow Function IIFE:**
  ```js
  (() => {
    console.log('arrow IIFE - DB CONNECTED TWO');
  })();
  ```
- **Parameterized IIFE:**
  ```js
  ((name) => {
    console.log('arrow IIFE - DB CONNECTED TWO name:', name);
  })('hitesh');
  ```

### Why Parentheses?
- The parentheses around the function turn it from a declaration to an expression, allowing it to be invoked immediately.
- The final `()` invokes the function.

### IIFE with Return Value
```js
const result = (function() {
  return 42;
})();
console.log(result); // 42
```

### IIFE for Scope Isolation
```js
var x = 10;
(function() {
  var x = 20;
  console.log('Inner x:', x); // 20
})();
console.log('Outer x:', x); // 10
```

---

## Use Cases for IIFE
- **Scope isolation:** Prevents variables from leaking into the global scope.
- **Module pattern:** Encapsulates private data and exposes only what is needed.
- **Initialization:** Runs setup code once, immediately.
- **Avoiding variable hoisting issues:** Keeps temporary variables out of the global or parent scope.

---

## Best Practices \& Common Pitfalls
- Always wrap the function in parentheses to ensure it is treated as an expression.
- Use IIFEs for code that should run once and not pollute the outer scope.
- Prefer ES6 modules, `let`, and `const` for most modern code, but IIFEs are still useful for legacy code and certain patterns.
- Avoid using IIFEs for code that needs to be reused elsewhere.
- Be careful with semicolon insertion; always use a semicolon before an IIFE if it follows another statement.

---

## Comparison: IIFE vs Regular Function
| Feature         | IIFE                                 | Regular Function         |
|-----------------|--------------------------------------|-------------------------|
| Invocation      | Immediately after definition         | When called explicitly  |
| Scope           | Creates its own local scope          | Scope depends on usage  |
| Use case        | Initialization, isolation, modules   | Reusable logic          |
| Syntax          | (function(){...})() or (()=>{...})() | function foo() {...}    |

---

## Real-World Use Cases
- **jQuery plugin pattern:**
  ```js
  (function($) {
    // jQuery plugin code here
  })(jQuery);
  ```
- **Polyfills and shims:**
  ```js
  (function() {
    if (!Array.prototype.myMethod) {
      Array.prototype.myMethod = function() { /* ... */ };
    }
  })();
  ```
- **Configuration blocks:**
  ```js
  (function(config) {
    // Use config object
  })({ debug: true });
  ```

---

## Key Takeaways
> - IIFEs execute immediately after they are defined.
> - Useful for creating private scopes and avoiding global variable pollution.
> - Can be named or anonymous, and can accept parameters.
> - Commonly used in module patterns, initialization, and legacy code.
> - Prefer ES6 modules and block scoping for most modern code, but IIFEs are still valuable in some scenarios.

---

## Common Pitfalls \& Warnings
> ⚠️ **Warning:**
> - Forgetting the extra parentheses can result in a function declaration instead of an IIFE.
> - If an IIFE follows another statement, use a semicolon to avoid errors due to automatic semicolon insertion.
> - Avoid using IIFEs for reusable code.

---

## Practice
**Try it yourself:**
- Write an IIFE that prints your name.
- Create an IIFE that takes two numbers and prints their sum.
- Use an IIFE to create a private counter variable and expose only an increment function.

**Quiz:**
```js
(function() {
  var a = 10;
  console.log(a);
})();
// What does this print?
```

---

## Further Reading
- [MDN: IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)
- [GeeksforGeeks: IIFE in JavaScript](https://www.geeksforgeeks.org/immediately-invoked-function-expression-iife-in-javascript/)

---

# 14_control_flow.js — JavaScript Control Flow

**Learning Goals:**
- Understand the use of if/else, switch, and ternary operators.
- Learn about comparison, logical, and nullish coalescing operators.
- Recognize truthy/falsy values and how to check for empty arrays/objects.
- Choose the right control flow construct for clarity and maintainability.

---

## Overview

Control flow statements determine the order in which code executes. JavaScript provides if/else, switch, and ternary operators for branching, as well as logical and comparison operators for complex conditions. Mastering these constructs is essential for writing clear, bug-free code.

---

## Syntax & Examples

### 1. if/else Statement
**When to use:**
- To execute code conditionally based on a boolean expression.

**Syntax:**
```js
if (condition) {
  // code block if true
} else if (otherCondition) {
  // code block if otherCondition is true
} else {
  // code block if none are true
}
```
**Example:**
```js
const age = 18;
if (age >= 18) {
  console.log('You are an adult.');
} else {
  console.log('You are a minor.');
}
```
**Best Practices:**
- Use braces `{}` even for single-line blocks for clarity.
- Keep conditions simple and readable.

---

### 2. switch Statement
**When to use:**
- To select one of many code blocks to execute based on the value of a variable.
- Useful for handling multiple discrete values.

**Syntax:**
```js
switch (expression) {
  case value1:
    // code block
    break;
  case value2:
    // code block
    break;
  default:
    // code block
}
```
**Example:**
```js
const fruit = 'apple';
switch (fruit) {
  case 'apple':
    console.log('It is an apple.');
    break;
  case 'banana':
    console.log('It is a banana.');
    break;
  default:
    console.log('Unknown fruit.');
}
```
**Best Practices:**
- Always include a `default` case.
- Use `break` to prevent fall-through unless intentional.

---

### 3. Ternary Operator
**When to use:**
- For concise conditional assignments or expressions.
- When you need a value based on a condition.

**Syntax:**
```js
condition ? exprIfTrue : exprIfFalse;
```
**Example:**
```js
const age = 20;
const status = age >= 18 ? 'adult' : 'minor';
console.log(status); // 'adult'
```
**Best Practices:**
- Use for simple conditions; avoid nesting ternaries for readability.

---

### 4. Logical Operators (&&, ||, !)
**When to use:**
- To combine multiple conditions or provide default values.

**Syntax:**
```js
if (a && b) { /* both must be true */ }
if (a || b) { /* either can be true */ }
if (!a) { /* a is false */ }
```
**Example:**
```js
const isLoggedIn = true;
const hasPermission = false;
if (isLoggedIn && hasPermission) {
  console.log('Access granted.');
} else {
  console.log('Access denied.');
}
```
**Best Practices:**
- Use parentheses to clarify complex logic.
- Short-circuiting can be used for default values: `const name = input || 'Guest';`

---

### 5. Nullish Coalescing Operator (??)
**When to use:**
- To provide a default value only when the left-hand side is `null` or `undefined` (not for other falsy values).

**Syntax:**
```js
const value = possiblyNull ?? defaultValue;
```
**Example:**
```js
let username = null;
let displayName = username ?? 'Anonymous';
console.log(displayName); // 'Anonymous'
```
**Best Practices:**
- Prefer `??` over `||` when you want to treat only `null`/`undefined` as missing.

---

### 6. Truthy and Falsy Values
**When to use:**
- To check if a value is considered true or false in a boolean context.

**Falsy values:** `false`, `0`, `-0`, `0n`, `''`, `null`, `undefined`, `NaN`
**Truthy values:** All other values (e.g., `'0'`, `[]`, `{}`, `'false'`)

**Example:**
```js
if ('') {
  console.log('This will not run.');
}
if ('hello') {
  console.log('This will run.');
}
```
**Best Practices:**
- Be explicit when checking for empty arrays/objects: `arr.length === 0`, `Object.keys(obj).length === 0`

---

### 7. Checking for Empty Arrays and Objects
**When to use:**
- To determine if a collection has any elements or properties.

**Example:**
```js
const arr = [];
if (arr.length === 0) {
  console.log('Array is empty');
}
const obj = {};
if (Object.keys(obj).length === 0) {
  console.log('Object is empty');
}
```
**Best Practices:**
- Use `Array.isArray()` to check if a variable is an array.
- For objects, use `Object.keys(obj).length` for emptiness.

---

## Comparison Table: JavaScript Control Flow Constructs

| Construct         | Use Case                        | Syntax Example                | Readability | Best For                |
|-------------------|---------------------------------|-------------------------------|-------------|------------------------|
| if/else           | General branching               | `if (a) {...} else {...}`     | High        | Most conditions         |
| switch            | Multiple discrete values        | `switch (x) {...}`            | Medium      | Many cases, enums      |
| ternary           | Inline conditional value        | `a ? b : c`                   | High        | Assignments, JSX       |
| logical operators | Combine/short-circuit logic     | `a && b`, `a || b`            | High        | Compound conditions     |
| nullish coalescing| Default for null/undefined      | `a ?? b`                      | High        | Optional/default values |

---

## Key Takeaways
> - Use if/else for most conditional logic.
> - Use switch for multiple discrete values.
> - Use ternary for concise value selection, not complex logic.
> - Use logical operators for combining conditions and defaulting.
> - Use nullish coalescing for defaulting only on null/undefined.
> - Always check for empty arrays/objects explicitly.

---

## Common Pitfalls \& Warnings
> ⚠️ **Warning:**
> - Using `==` can lead to unexpected type coercion. Always use `===` unless you have a specific reason.
> - Forgetting `break` in switch cases causes fall-through.
> - Ternary operators can reduce readability if overused or nested.
> - `||` treats all falsy values as missing; use `??` for null/undefined only.
> - Arrays and objects are always truthy, even if empty.

---

## Practice
**Try it yourself:**
- Write an if/else that checks if a number is positive, negative, or zero.
- Use a switch statement to print the name of a month given its number.
- Use a ternary operator to assign a status based on age.
- Use `??` to provide a default username.
- Check if an array or object is empty before processing.

**Quiz:**
```js
const x = 0;
if (x) {
  console.log('Truthy');
} else {
  console.log('Falsy');
}
// What does this print?
```

---

## Further Reading
- [MDN: Control flow and error handling](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling)
- [MDN: if...else](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else)
- [MDN: switch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch)
- [MDN: Logical operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators)
- [MDN: Ternary operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)
- [MDN: Nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator)

---

# 15_loops.js — JavaScript Loops

**Learning Goals:**
- Use different types of loops: for, while, do-while, for...of, for...in, forEach, map, filter, reduce.
- Understand loop control with break and continue.
- Iterate over arrays, objects, maps, and strings.
- Choose the right loop for the right scenario.

---

## Overview

Loops allow you to execute a block of code multiple times. JavaScript provides several loop constructs for different use cases, including iterating over arrays, objects, and more advanced data structures. Choosing the right loop improves code clarity, performance, and maintainability.

---

## Syntax & Examples

### 1. For Loop
**When to use:**
- When you know the number of iterations in advance (e.g., iterating over array indices).

**Syntax:**
```js
for (let i = 0; i < array.length; i++) {
  // code block
}
```
**Example:**
```js
const array = [1, 2, 3, 4, 5];
for (let i = 0; i < array.length; i++) {
  console.log('array element:', array[i]);
}
```
**Best Practices:**
- Use `let` for the loop variable to ensure block scope.
- Avoid off-by-one errors (check your start/end conditions).

---

### 2. While Loop
**When to use:**
- When the number of iterations is not known in advance; loop continues as long as the condition is true.

**Syntax:**
```js
while (condition) {
  // code block
}
```
**Example:**
```js
let count = 0;
while (count < 5) {
  console.log('count:', count);
  count++;
}
```
**Best Practices:**
- Ensure the loop condition will eventually become false to avoid infinite loops.

---

### 3. Do-While Loop
**When to use:**
- When you want the loop body to execute at least once, regardless of the condition.

**Syntax:**
```js
do {
  // code block
} while (condition);
```
**Example:**
```js
let num = 10;
do {
  console.log('num:', num);
  num++;
} while (num < 10);
// Output: num: 10 (runs once even though condition is false after first iteration)
```

---

### 4. For...of Loop
**When to use:**
- To iterate over iterable objects (arrays, strings, maps, sets).
- When you want the value directly, not the index/key.

**Syntax:**
```js
for (const value of iterable) {
  // code block
}
```
**Example:**
```js
const arr = ['a', 'b', 'c'];
for (const val of arr) {
  console.log('for...of value:', val);
}
```
**Best Practices:**
- Use for arrays, strings, maps, sets.
- Not suitable for plain objects (use for...in or Object.entries()).

---

### 5. For...in Loop
**When to use:**
- To iterate over the enumerable property keys of an object.
- Can be used with arrays, but not recommended (iterates over indices as strings).

**Syntax:**
```js
for (const key in object) {
  // code block
}
```
**Example:**
```js
const obj = {a: 1, b: 2};
for (const key in obj) {
  console.log('for...in key:', key, 'value:', obj[key]);
}
```
**Best Practices:**
- Use for objects, not arrays.
- Use `hasOwnProperty` check if you want to skip inherited properties.

---

### 6. forEach Method
**When to use:**
- To execute a function for each element in an array.
- When you don't need to break/continue or return a new array.

**Syntax:**
```js
array.forEach((element, index, array) => {
  // code block
});
```
**Example:**
```js
const arr = [1, 2, 3];
arr.forEach((item, idx) => {
  console.log('forEach item:', item, 'index:', idx);
});
```
**Best Practices:**
- Use for side effects (logging, updating external state).
- Does not support break/continue or return a value.

---

### 7. map Method
**When to use:**
- To create a new array by transforming each element of an array.

**Syntax:**
```js
const newArray = array.map((element, index, array) => {
  // return new value
});
```
**Example:**
```js
const nums = [1, 2, 3];
const squares = nums.map(n => n * n);
console.log('squares:', squares); // [1, 4, 9]
```
**Best Practices:**
- Always return a value from the callback.
- Does not mutate the original array.

---

### 8. filter Method
**When to use:**
- To create a new array with elements that pass a test.

**Syntax:**
```js
const filtered = array.filter((element, index, array) => {
  // return true to keep element
});
```
**Example:**
```js
const nums = [1, 2, 3, 4];
const even = nums.filter(n => n % 2 === 0);
console.log('even:', even); // [2, 4]
```
**Best Practices:**
- Return a boolean from the callback.
- Does not mutate the original array.

---

### 9. reduce Method
**When to use:**
- To reduce an array to a single value (sum, product, object, etc.).

**Syntax:**
```js
const result = array.reduce((accumulator, currentValue, index, array) => {
  // return new accumulator
}, initialValue);
```
**Example:**
```js
const nums = [1, 2, 3, 4];
const sum = nums.reduce((acc, n) => acc + n, 0);
console.log('sum:', sum); // 10
```
**Best Practices:**
- Always provide an initial value for the accumulator.
- Use for aggregating or transforming data.

---

## Comparison Table: JavaScript Loop Types

| Loop Type   | Use Case                        | Break/Continue | Returns New Array | Iterates Over      | Suitable For         |
|-------------|---------------------------------|:--------------:|:-----------------:|--------------------|---------------------|
| for         | Known # of iterations           |      Yes       |        No         | Indices            | Arrays, custom logic |
| while       | Unknown # of iterations         |      Yes       |        No         | Condition          | General             |
| do-while    | At least one execution needed   |      Yes       |        No         | Condition          | General             |
| for...of    | Iterable values                 |      Yes       |        No         | Values             | Arrays, strings, Map |
| for...in    | Object keys (enumerable)        |      Yes       |        No         | Keys               | Objects             |
| forEach     | Array elements (side effects)   |      No        |        No         | Values             | Arrays              |
| map         | Transform array                 |      No        |       Yes         | Values             | Arrays              |
| filter      | Filter array                    |      No        |       Yes         | Values             | Arrays              |
| reduce      | Aggregate array                 |      No        |   Single value    | Values             | Arrays              |

---

## Key Takeaways
> - Use for, while, and do-while for general looping needs.
> - Use for...of for arrays, strings, and maps; for...in for objects and arrays (indices).
> - Use forEach, map, filter, and reduce for array processing.
> - Use break and continue to control loop execution (not available in forEach/map/filter/reduce).
> - Prefer forEach/map/filter/reduce for functional-style array operations.
> - Choose the loop that best matches your data and intent for clarity and maintainability.

---

## Common Pitfalls \& Warnings
> ⚠️ **Warning:**
> - Using for...in on arrays iterates over indices, not values. for...of is preferred for arrays.
> - forEach does not return a new array or allow break/continue.
> - map/filter/reduce do not mutate the original array, but forEach can cause side effects.
> - Be careful with infinite loops and off-by-one errors.
> - Always provide an initial value to reduce to avoid bugs.

---

## Practice
**Try it yourself:**
- Write a for loop that prints numbers 1 to 10, skipping 5.
- Use for...of to print each character in a string.
- Use reduce to sum an array of numbers.
- Use map to double each value in an array.
- Use filter to select only odd numbers from an array.

**Quiz:**
```js
const arr = [2, 4, 6]
const result = arr.reduce((acc, val) => acc + val, 0)
console.log(result)
// What does this print?
```

---

## Further Reading
- [MDN: Loops and iteration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration)
- [MDN: for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)
- [MDN: forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
- [MDN: map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
- [MDN: filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
- [MDN: reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
